<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A priority queue implemented with a binary heap."><title>BinaryHeap in std::collections - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="https://doc.rust-lang.org/static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="1.88.0" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items1.88.0.js"></script><script defer src="../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="https://doc.rust-lang.org/static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../index.html"><img class="rust-logo" src="../../static.files/rust-logo-9a9549ea.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../index.html"><img class="rust-logo" src="../../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../index.html">std</a><span class="version">1.88.0</span></h2></div><div class="version">(6b00bc388	2025-06-23)</div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="struct.BinaryHeap.html#">Binary<wbr>Heap</a></h2><h3><a href="struct.BinaryHeap.html#">Sections</a></h3><ul class="block top-toc"><li><a href="struct.BinaryHeap.html#examples" title="Examples">Examples</a><ul><li><a href="struct.BinaryHeap.html#min-heap" title="Min-heap">Min-heap</a></li></ul></li><li><a href="struct.BinaryHeap.html#time-complexity" title="Time complexity">Time complexity</a></li></ul><h3><a href="struct.BinaryHeap.html#implementations">Methods</a></h3><ul class="block method"><li><a href="struct.BinaryHeap.html#method.allocator" title="allocator">allocator</a></li><li><a href="struct.BinaryHeap.html#method.append" title="append">append</a></li><li><a href="struct.BinaryHeap.html#method.as_slice" title="as_slice">as_slice</a></li><li><a href="struct.BinaryHeap.html#method.capacity" title="capacity">capacity</a></li><li><a href="struct.BinaryHeap.html#method.clear" title="clear">clear</a></li><li><a href="struct.BinaryHeap.html#method.drain" title="drain">drain</a></li><li><a href="struct.BinaryHeap.html#method.drain_sorted" title="drain_sorted">drain_sorted</a></li><li><a href="struct.BinaryHeap.html#method.into_iter_sorted" title="into_iter_sorted">into_iter_sorted</a></li><li><a href="struct.BinaryHeap.html#method.into_sorted_vec" title="into_sorted_vec">into_sorted_vec</a></li><li><a href="struct.BinaryHeap.html#method.into_vec" title="into_vec">into_vec</a></li><li><a href="struct.BinaryHeap.html#method.is_empty" title="is_empty">is_empty</a></li><li><a href="struct.BinaryHeap.html#method.iter" title="iter">iter</a></li><li><a href="struct.BinaryHeap.html#method.len" title="len">len</a></li><li><a href="struct.BinaryHeap.html#method.new" title="new">new</a></li><li><a href="struct.BinaryHeap.html#method.new_in" title="new_in">new_in</a></li><li><a href="struct.BinaryHeap.html#method.peek" title="peek">peek</a></li><li><a href="struct.BinaryHeap.html#method.peek_mut" title="peek_mut">peek_mut</a></li><li><a href="struct.BinaryHeap.html#method.pop" title="pop">pop</a></li><li><a href="struct.BinaryHeap.html#method.push" title="push">push</a></li><li><a href="struct.BinaryHeap.html#method.reserve" title="reserve">reserve</a></li><li><a href="struct.BinaryHeap.html#method.reserve_exact" title="reserve_exact">reserve_exact</a></li><li><a href="struct.BinaryHeap.html#method.retain" title="retain">retain</a></li><li><a href="struct.BinaryHeap.html#method.shrink_to" title="shrink_to">shrink_to</a></li><li><a href="struct.BinaryHeap.html#method.shrink_to_fit" title="shrink_to_fit">shrink_to_fit</a></li><li><a href="struct.BinaryHeap.html#method.try_reserve" title="try_reserve">try_reserve</a></li><li><a href="struct.BinaryHeap.html#method.try_reserve_exact" title="try_reserve_exact">try_reserve_exact</a></li><li><a href="struct.BinaryHeap.html#method.with_capacity" title="with_capacity">with_capacity</a></li><li><a href="struct.BinaryHeap.html#method.with_capacity_in" title="with_capacity_in">with_capacity_in</a></li></ul><h3><a href="struct.BinaryHeap.html#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="struct.BinaryHeap.html#impl-Clone-for-BinaryHeap%3CT,+A%3E" title="Clone">Clone</a></li><li><a href="struct.BinaryHeap.html#impl-Debug-for-BinaryHeap%3CT,+A%3E" title="Debug">Debug</a></li><li><a href="struct.BinaryHeap.html#impl-Default-for-BinaryHeap%3CT%3E" title="Default">Default</a></li><li><a href="struct.BinaryHeap.html#impl-Extend%3C%26T%3E-for-BinaryHeap%3CT,+A%3E" title="Extend&#60;&#38;&#39;a T&#62;">Extend&#60;&#38;&#39;a T&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-Extend%3CT%3E-for-BinaryHeap%3CT,+A%3E" title="Extend&#60;T&#62;">Extend&#60;T&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-From%3CBinaryHeap%3CT,+A%3E%3E-for-Vec%3CT,+A%3E" title="From&#60;BinaryHeap&#60;T, A&#62;&#62;">From&#60;BinaryHeap&#60;T, A&#62;&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-From%3CVec%3CT,+A%3E%3E-for-BinaryHeap%3CT,+A%3E" title="From&#60;Vec&#60;T, A&#62;&#62;">From&#60;Vec&#60;T, A&#62;&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-From%3C%5BT;+N%5D%3E-for-BinaryHeap%3CT%3E" title="From&#60;[T; N]&#62;">From&#60;[T; N]&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-FromIterator%3CT%3E-for-BinaryHeap%3CT%3E" title="FromIterator&#60;T&#62;">FromIterator&#60;T&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-IntoIterator-for-%26BinaryHeap%3CT,+A%3E" title="IntoIterator">IntoIterator</a></li><li><a href="struct.BinaryHeap.html#impl-IntoIterator-for-BinaryHeap%3CT,+A%3E" title="IntoIterator">IntoIterator</a></li></ul><h3><a href="struct.BinaryHeap.html#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="struct.BinaryHeap.html#impl-Freeze-for-BinaryHeap%3CT,+A%3E" title="Freeze">Freeze</a></li><li><a href="struct.BinaryHeap.html#impl-RefUnwindSafe-for-BinaryHeap%3CT,+A%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="struct.BinaryHeap.html#impl-Send-for-BinaryHeap%3CT,+A%3E" title="Send">Send</a></li><li><a href="struct.BinaryHeap.html#impl-Sync-for-BinaryHeap%3CT,+A%3E" title="Sync">Sync</a></li><li><a href="struct.BinaryHeap.html#impl-Unpin-for-BinaryHeap%3CT,+A%3E" title="Unpin">Unpin</a></li><li><a href="struct.BinaryHeap.html#impl-UnwindSafe-for-BinaryHeap%3CT,+A%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="struct.BinaryHeap.html#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="struct.BinaryHeap.html#impl-Any-for-T" title="Any">Any</a></li><li><a href="struct.BinaryHeap.html#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="struct.BinaryHeap.html#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="struct.BinaryHeap.html#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="struct.BinaryHeap.html#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In std::<wbr>collections</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">std</a>::<wbr><a href="index.html">collections</a></div><h1>Struct <span class="struct">BinaryHeap</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#274-277">Source</a> </span></div><pre class="rust item-decl"><code>pub struct BinaryHeap&lt;T, A = <a class="struct" href="../alloc/struct.Global.html" title="struct std::alloc::Global">Global</a>&gt;<div class="where">where
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div>{ <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A priority queue implemented with a binary heap.</p>
<p>This will be a max-heap.</p>
<p>It is a logic error for an item to be modified in such a way that the
itemâs ordering relative to any other item, as determined by the <a href="../cmp/trait.Ord.html" title="trait std::cmp::Ord"><code>Ord</code></a>
trait, changes while it is in the heap. This is normally only possible
through interior mutability, global state, I/O, or unsafe code. The
behavior resulting from such a logic error is not specified, but will
be encapsulated to the <code>BinaryHeap</code> that observed the logic error and not
result in undefined behavior. This could include panics, incorrect results,
aborts, memory leaks, and non-termination.</p>
<p>As long as no elements change their relative order while being in the heap
as described above, the API of <code>BinaryHeap</code> guarantees that the heap
invariant remains intact i.e. its methods all behave as documented. For
example if a method is documented as iterating in sorted order, thatâs
guaranteed to work as long as elements in the heap have not changed order,
even in the presence of closures getting unwinded out of, iterators getting
leaked, and similar foolishness.</p>
<h2 id="examples"><a class="doc-anchor" href="struct.BinaryHeap.html#examples">Â§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;

<span class="comment">// Type inference lets us omit an explicit type signature (which
// would be `BinaryHeap&lt;i32&gt;` in this example).
</span><span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();

<span class="comment">// We can use peek to look at the next item in the heap. In this case,
// there's no items in there yet so we get None.
</span><span class="macro">assert_eq!</span>(heap.peek(), <span class="prelude-val">None</span>);

<span class="comment">// Let's add some scores...
</span>heap.push(<span class="number">1</span>);
heap.push(<span class="number">5</span>);
heap.push(<span class="number">2</span>);

<span class="comment">// Now peek shows the most important item in the heap.
</span><span class="macro">assert_eq!</span>(heap.peek(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));

<span class="comment">// We can check the length of a heap.
</span><span class="macro">assert_eq!</span>(heap.len(), <span class="number">3</span>);

<span class="comment">// We can iterate over the items in the heap, although they are returned in
// a random order.
</span><span class="kw">for </span>x <span class="kw">in </span><span class="kw-2">&amp;</span>heap {
    <span class="macro">println!</span>(<span class="string">"{x}"</span>);
}

<span class="comment">// If we instead pop these scores, they should come back in order.
</span><span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">None</span>);

<span class="comment">// We can clear the heap of any remaining items.
</span>heap.clear();

<span class="comment">// The heap should now be empty.
</span><span class="macro">assert!</span>(heap.is_empty())</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++//+Type+inference+lets+us+omit+an+explicit+type+signature+(which%0A++++//+would+be+%60BinaryHeap%3Ci32%3E%60+in+this+example).%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++//+We+can+use+peek+to+look+at+the+next+item+in+the+heap.+In+this+case,%0A++++//+there's+no+items+in+there+yet+so+we+get+None.%0A++++assert_eq!(heap.peek(),+None);%0A++++%0A++++//+Let's+add+some+scores...%0A++++heap.push(1);%0A++++heap.push(5);%0A++++heap.push(2);%0A++++%0A++++//+Now+peek+shows+the+most+important+item+in+the+heap.%0A++++assert_eq!(heap.peek(),+Some(%265));%0A++++%0A++++//+We+can+check+the+length+of+a+heap.%0A++++assert_eq!(heap.len(),+3);%0A++++%0A++++//+We+can+iterate+over+the+items+in+the+heap,+although+they+are+returned+in%0A++++//+a+random+order.%0A++++for+x+in+%26heap+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A++++%0A++++//+If+we+instead+pop+these+scores,+they+should+come+back+in+order.%0A++++assert_eq!(heap.pop(),+Some(5));%0A++++assert_eq!(heap.pop(),+Some(2));%0A++++assert_eq!(heap.pop(),+Some(1));%0A++++assert_eq!(heap.pop(),+None);%0A++++%0A++++//+We+can+clear+the+heap+of+any+remaining+items.%0A++++heap.clear();%0A++++%0A++++//+The+heap+should+now+be+empty.%0A++++assert!(heap.is_empty())%0A%7D&amp;edition=2024"></a></div>
<p>A <code>BinaryHeap</code> with a known list of items can be initialized from an array:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;

<span class="kw">let </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+heap+=+BinaryHeap::from(%5B1,+5,+2%5D);%0A%7D&amp;edition=2024"></a></div>
<h3 id="min-heap"><a class="doc-anchor" href="struct.BinaryHeap.html#min-heap">Â§</a>Min-heap</h3>
<p>Either <a href="../cmp/struct.Reverse.html" title="struct std::cmp::Reverse"><code>core::cmp::Reverse</code></a> or a custom <a href="../cmp/trait.Ord.html" title="trait std::cmp::Ord"><code>Ord</code></a> implementation can be used to
make <code>BinaryHeap</code> a min-heap. This makes <code>heap.pop()</code> return the smallest
value instead of the greatest one.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">use </span>std::cmp::Reverse;

<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();

<span class="comment">// Wrap values in `Reverse`
</span>heap.push(Reverse(<span class="number">1</span>));
heap.push(Reverse(<span class="number">5</span>));
heap.push(Reverse(<span class="number">2</span>));

<span class="comment">// If we pop these scores now, they should come back in the reverse order.
</span><span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">Some</span>(Reverse(<span class="number">1</span>)));
<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">Some</span>(Reverse(<span class="number">2</span>)));
<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">Some</span>(Reverse(<span class="number">5</span>)));
<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::cmp::Reverse;%0A++++%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++//+Wrap+values+in+%60Reverse%60%0A++++heap.push(Reverse(1));%0A++++heap.push(Reverse(5));%0A++++heap.push(Reverse(2));%0A++++%0A++++//+If+we+pop+these+scores+now,+they+should+come+back+in+the+reverse+order.%0A++++assert_eq!(heap.pop(),+Some(Reverse(1)));%0A++++assert_eq!(heap.pop(),+Some(Reverse(2)));%0A++++assert_eq!(heap.pop(),+Some(Reverse(5)));%0A++++assert_eq!(heap.pop(),+None);%0A%7D&amp;edition=2024"></a></div>
<h2 id="time-complexity"><a class="doc-anchor" href="struct.BinaryHeap.html#time-complexity">Â§</a>Time complexity</h2><div><table><thead><tr><th><a href="struct.BinaryHeap.html#method.push" title="method std::collections::BinaryHeap::push">push</a></th><th><a href="struct.BinaryHeap.html#method.pop" title="method std::collections::BinaryHeap::pop">pop</a></th><th><a href="struct.BinaryHeap.html#method.peek" title="method std::collections::BinaryHeap::peek">peek</a>/<a href="struct.BinaryHeap.html#method.peek_mut" title="method std::collections::BinaryHeap::peek_mut">peek_mut</a></th></tr></thead><tbody>
<tr><td><em>O</em>(1)~</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(1)</td></tr>
</tbody></table>
</div>
<p>The value for <code>push</code> is an expected cost; the method documentation gives a
more detailed analysis.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="struct.BinaryHeap.html#implementations" class="anchor">Â§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-BinaryHeap%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#499">Source</a><a href="struct.BinaryHeap.html#impl-BinaryHeap%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.80.0">1.0.0 (const: 1.80.0)</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#514">Source</a></span><h4 class="code-header">pub const fn <a href="struct.BinaryHeap.html#method.new" class="fn">new</a>() -&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates an empty <code>BinaryHeap</code> as a max-heap.</p>
<h5 id="examples-1"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-1">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
heap.push(<span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.push(4);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_capacity" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#535">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.with_capacity" class="fn">with_capacity</a>(capacity: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates an empty <code>BinaryHeap</code> with at least the specified capacity.</p>
<p>The binary heap will be able to hold at least <code>capacity</code> elements without
reallocating. This method is allowed to allocate for more elements than
<code>capacity</code>. If <code>capacity</code> is zero, the binary heap will not allocate.</p>
<h5 id="examples-2"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-2">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::with_capacity(<span class="number">10</span>);
heap.push(<span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::with_capacity(10);%0A++++heap.push(4);%0A%7D&amp;edition=2024"></a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BinaryHeap%3CT,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#540">Source</a><a href="struct.BinaryHeap.html#impl-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    T: <a class="trait" href="../cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a>,
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#557">Source</a><h4 class="code-header">pub const fn <a href="struct.BinaryHeap.html#method.new_in" class="fn">new_in</a>(alloc: A) -&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ð¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span></div></span></summary><div class="docblock"><p>Creates an empty <code>BinaryHeap</code> as a max-heap, using <code>A</code> as allocator.</p>
<h5 id="examples-3"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-3">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(allocator_api)]

</span><span class="kw">use </span>std::alloc::System;
<span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new_in(System);
heap.push(<span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::alloc::System;%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new_in(System);%0A++++heap.push(4);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_capacity_in" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#581">Source</a><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.with_capacity_in" class="fn">with_capacity_in</a>(capacity: <a class="primitive" href="../primitive.usize.html">usize</a>, alloc: A) -&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ð¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span></div></span></summary><div class="docblock"><p>Creates an empty <code>BinaryHeap</code> with at least the specified capacity, using <code>A</code> as allocator.</p>
<p>The binary heap will be able to hold at least <code>capacity</code> elements without
reallocating. This method is allowed to allocate for more elements than
<code>capacity</code>. If <code>capacity</code> is zero, the binary heap will not allocate.</p>
<h5 id="examples-4"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-4">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(allocator_api)]

</span><span class="kw">use </span>std::alloc::System;
<span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::with_capacity_in(<span class="number">10</span>, System);
heap.push(<span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::alloc::System;%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::with_capacity_in(10,+System);%0A++++heap.push(4);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#615">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.peek_mut" class="fn">peek_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="struct" href="binary_heap/struct.PeekMut.html" title="struct std::collections::binary_heap::PeekMut">PeekMut</a>&lt;'_, T, A&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable reference to the greatest item in the binary heap, or
<code>None</code> if it is empty.</p>
<p>Note: If the <code>PeekMut</code> value is leaked, some heap elements might get
leaked along with it, but the remaining elements will remain a valid
heap.</p>
<h5 id="examples-5"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-5">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
<span class="macro">assert!</span>(heap.peek_mut().is_none());

heap.push(<span class="number">1</span>);
heap.push(<span class="number">5</span>);
heap.push(<span class="number">2</span>);
<span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">mut </span>val) = heap.peek_mut() {
    <span class="kw-2">*</span>val = <span class="number">0</span>;
}
<span class="macro">assert_eq!</span>(heap.peek(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++assert!(heap.peek_mut().is_none());%0A++++%0A++++heap.push(1);%0A++++heap.push(5);%0A++++heap.push(2);%0A++++if+let+Some(mut+val)+=+heap.peek_mut()+%7B%0A++++++++*val+=+0;%0A++++%7D%0A++++assert_eq!(heap.peek(),+Some(%262));%0A%7D&amp;edition=2024"></a></div>
<h5 id="time-complexity-1"><a class="doc-anchor" href="struct.BinaryHeap.html#time-complexity-1">Â§</a>Time complexity</h5>
<p>If the item is modified then the worst case time complexity is <em>O</em>(log(<em>n</em>)),
otherwise itâs <em>O</em>(1).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#639">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.pop" class="fn">pop</a>(&amp;mut self) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Removes the greatest item from the binary heap and returns it, or <code>None</code> if it
is empty.</p>
<h5 id="examples-6"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-6">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">Some</span>(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert_eq!(heap.pop(),+Some(3));%0A++++assert_eq!(heap.pop(),+Some(1));%0A++++assert_eq!(heap.pop(),+None);%0A%7D&amp;edition=2024"></a></div>
<h5 id="time-complexity-2"><a class="doc-anchor" href="struct.BinaryHeap.html#time-complexity-2">Â§</a>Time complexity</h5>
<p>The worst case cost of <code>pop</code> on a heap containing <em>n</em> elements is <em>O</em>(log(<em>n</em>)).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#684">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.push" class="fn">push</a>(&amp;mut self, item: T)</h4></section></summary><div class="docblock"><p>Pushes an item onto the binary heap.</p>
<h5 id="examples-7"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-7">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
heap.push(<span class="number">3</span>);
heap.push(<span class="number">5</span>);
heap.push(<span class="number">1</span>);

<span class="macro">assert_eq!</span>(heap.len(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(heap.peek(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.push(3);%0A++++heap.push(5);%0A++++heap.push(1);%0A++++%0A++++assert_eq!(heap.len(),+3);%0A++++assert_eq!(heap.peek(),+Some(%265));%0A%7D&amp;edition=2024"></a></div>
<h5 id="time-complexity-3"><a class="doc-anchor" href="struct.BinaryHeap.html#time-complexity-3">Â§</a>Time complexity</h5>
<p>The expected cost of <code>push</code>, averaged over every possible ordering of
the elements being pushed, and over a sufficiently large number of
pushes, is <em>O</em>(1). This is the most meaningful cost metric when pushing
elements that are <em>not</em> already in any sorted pattern.</p>
<p>The time complexity degrades if elements are pushed in predominantly
ascending order. In the worst case, elements are pushed in ascending
sorted order and the amortized cost per push is <em>O</em>(log(<em>n</em>)) against a heap
containing <em>n</em> elements.</p>
<p>The worst case cost of a <em>single</em> call to <code>push</code> is <em>O</em>(<em>n</em>). The worst case
occurs when capacity is exhausted and needs a resize. The resize cost
has been amortized in the previous figures.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_sorted_vec" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#711">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.into_sorted_vec" class="fn">into_sorted_vec</a>(self) -&gt; <a class="struct" href="../vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;T, A&gt;</h4></section></summary><div class="docblock"><p>Consumes the <code>BinaryHeap</code> and returns a vector in sorted
(ascending) order.</p>
<h5 id="examples-8"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-8">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;

<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>]);
heap.push(<span class="number">6</span>);
heap.push(<span class="number">3</span>);

<span class="kw">let </span>vec = heap.into_sorted_vec();
<span class="macro">assert_eq!</span>(vec, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+2,+4,+5,+7%5D);%0A++++heap.push(6);%0A++++heap.push(3);%0A++++%0A++++let+vec+=+heap.into_sorted_vec();%0A++++assert_eq!(vec,+%5B1,+2,+3,+4,+5,+6,+7%5D);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.append" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.11.0">1.11.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#936">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.append" class="fn">append</a>(&amp;mut self, other: &amp;mut <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;)</h4></section></summary><div class="docblock"><p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p>
<h5 id="examples-9"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-9">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;

<span class="kw">let </span><span class="kw-2">mut </span>a = BinaryHeap::from([-<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);
<span class="kw">let </span><span class="kw-2">mut </span>b = BinaryHeap::from([-<span class="number">20</span>, <span class="number">5</span>, <span class="number">43</span>]);

a.append(<span class="kw-2">&amp;mut </span>b);

<span class="macro">assert_eq!</span>(a.into_sorted_vec(), [-<span class="number">20</span>, -<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">43</span>]);
<span class="macro">assert!</span>(b.is_empty());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+a+=+BinaryHeap::from(%5B-10,+1,+2,+3,+3%5D);%0A++++let+mut+b+=+BinaryHeap::from(%5B-20,+5,+43%5D);%0A++++%0A++++a.append(%26mut+b);%0A++++%0A++++assert_eq!(a.into_sorted_vec(),+%5B-20,+-10,+1,+2,+3,+3,+5,+43%5D);%0A++++assert!(b.is_empty());%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.drain_sorted" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#975">Source</a><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.drain_sorted" class="fn">drain_sorted</a>(&amp;mut self) -&gt; <a class="struct" href="binary_heap/struct.DrainSorted.html" title="struct std::collections::binary_heap::DrainSorted">DrainSorted</a>&lt;'_, T, A&gt; <a href="struct.BinaryHeap.html#" class="tooltip" data-notable-ty="DrainSorted&lt;&#39;_, T, A&gt;">â</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ð¬</span><span>This is a nightly-only experimental API. (<code>binary_heap_drain_sorted</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/59278">#59278</a>)</span></div></span></summary><div class="docblock"><p>Clears the binary heap, returning an iterator over the removed elements
in heap order. If the iterator is dropped before being fully consumed,
it drops the remaining elements in heap order.</p>
<p>The returned iterator keeps a mutable borrow on the heap to optimize
its implementation.</p>
<p>Note:</p>
<ul>
<li><code>.drain_sorted()</code> is <em>O</em>(<em>n</em> * log(<em>n</em>)); much slower than <code>.drain()</code>.
You should use the latter for most cases.</li>
</ul>
<h5 id="examples-10"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-10">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(binary_heap_drain_sorted)]
</span><span class="kw">use </span>std::collections::BinaryHeap;

<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="macro">assert_eq!</span>(heap.len(), <span class="number">5</span>);

drop(heap.drain_sorted()); <span class="comment">// removes all elements in heap order
</span><span class="macro">assert_eq!</span>(heap.len(), <span class="number">0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(binary_heap_drain_sorted)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5%5D);%0A++++assert_eq!(heap.len(),+5);%0A++++%0A++++drop(heap.drain_sorted());+//+removes+all+elements+in+heap+order%0A++++assert_eq!(heap.len(),+0);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.retain" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#998-1000">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.retain" class="fn">retain</a>&lt;F&gt;(&amp;mut self, f: F)<div class="where">where
    F: <a class="trait" href="../ops/trait.FnMut.html" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="../primitive.reference.html">&amp;T</a>) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Retains only the elements specified by the predicate.</p>
<p>In other words, remove all elements <code>e</code> for which <code>f(&amp;e)</code> returns
<code>false</code>. The elements are visited in unsorted (and unspecified) order.</p>
<h5 id="examples-11"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-11">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;

<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([-<span class="number">10</span>, -<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">13</span>]);

heap.retain(|x| x % <span class="number">2 </span>== <span class="number">0</span>); <span class="comment">// only keep even numbers

</span><span class="macro">assert_eq!</span>(heap.into_sorted_vec(), [-<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>])</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+heap+=+BinaryHeap::from(%5B-10,+-5,+1,+2,+4,+13%5D);%0A++++%0A++++heap.retain(%7Cx%7C+x+%25+2+==+0);+//+only+keep+even+numbers%0A++++%0A++++assert_eq!(heap.into_sorted_vec(),+%5B-10,+2,+4%5D)%0A%7D&amp;edition=2024"></a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-BinaryHeap%3CT,+A%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1018">Source</a><a href="struct.BinaryHeap.html#impl-BinaryHeap%3CT,+A%3E-1" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1037">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.iter" class="fn">iter</a>(&amp;self) -&gt; <a class="struct" href="binary_heap/struct.Iter.html" title="struct std::collections::binary_heap::Iter">Iter</a>&lt;'_, T&gt; <a href="struct.BinaryHeap.html#" class="tooltip" data-notable-ty="Iter&lt;&#39;_, T&gt;">â</a></h4></section></summary><div class="docblock"><p>Returns an iterator visiting all values in the underlying vector, in
arbitrary order.</p>
<h5 id="examples-12"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-12">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);

<span class="comment">// Print 1, 2, 3, 4 in arbitrary order
</span><span class="kw">for </span>x <span class="kw">in </span>heap.iter() {
    <span class="macro">println!</span>(<span class="string">"{x}"</span>);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4%5D);%0A++++%0A++++//+Print+1,+2,+3,+4+in+arbitrary+order%0A++++for+x+in+heap.iter()+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter_sorted" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1057">Source</a><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.into_iter_sorted" class="fn">into_iter_sorted</a>(self) -&gt; <a class="struct" href="binary_heap/struct.IntoIterSorted.html" title="struct std::collections::binary_heap::IntoIterSorted">IntoIterSorted</a>&lt;T, A&gt; <a href="struct.BinaryHeap.html#" class="tooltip" data-notable-ty="IntoIterSorted&lt;T, A&gt;">â</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ð¬</span><span>This is a nightly-only experimental API. (<code>binary_heap_into_iter_sorted</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/59278">#59278</a>)</span></div></span></summary><div class="docblock"><p>Returns an iterator which retrieves elements in heap order.</p>
<p>This method consumes the original heap.</p>
<h5 id="examples-13"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-13">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(binary_heap_into_iter_sorted)]
</span><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert_eq!</span>(heap.into_iter_sorted().take(<span class="number">2</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), [<span class="number">5</span>, <span class="number">4</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(binary_heap_into_iter_sorted)%5D%0A%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5%5D);%0A++++%0A++++assert_eq!(heap.into_iter_sorted().take(2).collect::%3CVec%3C_%3E%3E(),+%5B5,+4%5D);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1084">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.peek" class="fn">peek</a>(&amp;self) -&gt; <a class="enum" href="../option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="../primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the greatest item in the binary heap, or <code>None</code> if it is empty.</p>
<h5 id="examples-14"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-14">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
<span class="macro">assert_eq!</span>(heap.peek(), <span class="prelude-val">None</span>);

heap.push(<span class="number">1</span>);
heap.push(<span class="number">5</span>);
heap.push(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(heap.peek(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));
</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++assert_eq!(heap.peek(),+None);%0A++++%0A++++heap.push(1);%0A++++heap.push(5);%0A++++heap.push(2);%0A++++assert_eq!(heap.peek(),+Some(%265));%0A%7D&amp;edition=2024"></a></div>
<h5 id="time-complexity-4"><a class="doc-anchor" href="struct.BinaryHeap.html#time-complexity-4">Â§</a>Time complexity</h5>
<p>Cost is <em>O</em>(1) in the worst case.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capacity" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1102">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.capacity" class="fn">capacity</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of elements the binary heap can hold without reallocating.</p>
<h5 id="examples-15"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-15">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::with_capacity(<span class="number">100</span>);
<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">100</span>);
heap.push(<span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::with_capacity(100);%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.push(4);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reserve_exact" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1133">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.reserve_exact" class="fn">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves the minimum capacity for at least <code>additional</code> elements more than
the current length. Unlike <a href="struct.BinaryHeap.html#method.reserve" title="method std::collections::BinaryHeap::reserve"><code>reserve</code></a>, this will not
deliberately over-allocate to speculatively avoid frequent allocations.
After calling <code>reserve_exact</code>, capacity will be greater than or equal to
<code>self.len() + additional</code>. Does nothing if the capacity is already
sufficient.</p>
<h5 id="panics"><a class="doc-anchor" href="struct.BinaryHeap.html#panics">Â§</a>Panics</h5>
<p>Panics if the new capacity overflows <a href="../primitive.usize.html" title="primitive usize"><code>usize</code></a>.</p>
<h5 id="examples-16"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-16">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
heap.reserve_exact(<span class="number">100</span>);
<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">100</span>);
heap.push(<span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.reserve_exact(100);%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.push(4);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reserve" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1159">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.reserve" class="fn">reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves capacity for at least <code>additional</code> elements more than the
current length. The allocator may reserve more space to speculatively
avoid frequent allocations. After calling <code>reserve</code>,
capacity will be greater than or equal to <code>self.len() + additional</code>.
Does nothing if capacity is already sufficient.</p>
<h5 id="panics-1"><a class="doc-anchor" href="struct.BinaryHeap.html#panics-1">Â§</a>Panics</h5>
<p>Panics if the new capacity overflows <a href="../primitive.usize.html" title="primitive usize"><code>usize</code></a>.</p>
<h5 id="examples-17"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-17">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
heap.reserve(<span class="number">100</span>);
<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">100</span>);
heap.push(<span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++heap.reserve(100);%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.push(4);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_reserve_exact" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1201">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.try_reserve_exact" class="fn">try_reserve_exact</a>(
    &amp;mut self,
    additional: <a class="primitive" href="../primitive.usize.html">usize</a>,
) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit.html">()</a>, <a class="struct" href="struct.TryReserveError.html" title="struct std::collections::TryReserveError">TryReserveError</a>&gt;</h4></section></summary><div class="docblock"><p>Tries to reserve the minimum capacity for at least <code>additional</code> elements
more than the current length. Unlike <a href="struct.BinaryHeap.html#method.try_reserve" title="method std::collections::BinaryHeap::try_reserve"><code>try_reserve</code></a>, this will not
deliberately over-allocate to speculatively avoid frequent allocations.
After calling <code>try_reserve_exact</code>, capacity will be greater than or
equal to <code>self.len() + additional</code> if it returns <code>Ok(())</code>.
Does nothing if the capacity is already sufficient.</p>
<p>Note that the allocator may give the collection more space than it
requests. Therefore, capacity can not be relied upon to be precisely
minimal. Prefer <a href="struct.BinaryHeap.html#method.try_reserve" title="method std::collections::BinaryHeap::try_reserve"><code>try_reserve</code></a> if future insertions are expected.</p>
<h5 id="errors"><a class="doc-anchor" href="struct.BinaryHeap.html#errors">Â§</a>Errors</h5>
<p>If the capacity overflows, or the allocator reports a failure, then an error
is returned.</p>
<h5 id="examples-18"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-18">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">use </span>std::collections::TryReserveError;

<span class="kw">fn </span>find_max_slow(data: <span class="kw-2">&amp;</span>[u32]) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="prelude-ty">Option</span>&lt;u32&gt;, TryReserveError&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();

    <span class="comment">// Pre-reserve the memory, exiting if we can't
    </span>heap.try_reserve_exact(data.len())<span class="question-mark">?</span>;

    <span class="comment">// Now we know this can't OOM in the middle of our complex work
    </span>heap.extend(data.iter());

    <span class="prelude-val">Ok</span>(heap.pop())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::collections::TryReserveError;%0A++++%0A++++fn+find_max_slow(data:+%26%5Bu32%5D)+-%3E+Result%3COption%3Cu32%3E,+TryReserveError%3E+%7B%0A++++++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++++++//+Pre-reserve+the+memory,+exiting+if+we+can't%0A++++++++heap.try_reserve_exact(data.len())?;%0A++++%0A++++++++//+Now+we+know+this+can't+OOM+in+the+middle+of+our+complex+work%0A++++++++heap.extend(data.iter());%0A++++%0A++++++++Ok(heap.pop())%0A++++%7D%0A++++find_max_slow(%26%5B1,+2,+3%5D).expect(%22why+is+the+test+harness+OOMing+on+12+bytes?%22);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_reserve" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1237">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.try_reserve" class="fn">try_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit.html">()</a>, <a class="struct" href="struct.TryReserveError.html" title="struct std::collections::TryReserveError">TryReserveError</a>&gt;</h4></section></summary><div class="docblock"><p>Tries to reserve capacity for at least <code>additional</code> elements more than the
current length. The allocator may reserve more space to speculatively
avoid frequent allocations. After calling <code>try_reserve</code>, capacity will be
greater than or equal to <code>self.len() + additional</code> if it returns
<code>Ok(())</code>. Does nothing if capacity is already sufficient. This method
preserves the contents even if an error occurs.</p>
<h5 id="errors-1"><a class="doc-anchor" href="struct.BinaryHeap.html#errors-1">Â§</a>Errors</h5>
<p>If the capacity overflows, or the allocator reports a failure, then an error
is returned.</p>
<h5 id="examples-19"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-19">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">use </span>std::collections::TryReserveError;

<span class="kw">fn </span>find_max_slow(data: <span class="kw-2">&amp;</span>[u32]) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="prelude-ty">Option</span>&lt;u32&gt;, TryReserveError&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();

    <span class="comment">// Pre-reserve the memory, exiting if we can't
    </span>heap.try_reserve(data.len())<span class="question-mark">?</span>;

    <span class="comment">// Now we know this can't OOM in the middle of our complex work
    </span>heap.extend(data.iter());

    <span class="prelude-val">Ok</span>(heap.pop())
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::collections::TryReserveError;%0A++++%0A++++fn+find_max_slow(data:+%26%5Bu32%5D)+-%3E+Result%3COption%3Cu32%3E,+TryReserveError%3E+%7B%0A++++++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++++++//+Pre-reserve+the+memory,+exiting+if+we+can't%0A++++++++heap.try_reserve(data.len())?;%0A++++%0A++++++++//+Now+we+know+this+can't+OOM+in+the+middle+of+our+complex+work%0A++++++++heap.extend(data.iter());%0A++++%0A++++++++Ok(heap.pop())%0A++++%7D%0A++++find_max_slow(%26%5B1,+2,+3%5D).expect(%22why+is+the+test+harness+OOMing+on+12+bytes?%22);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shrink_to_fit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1256">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.shrink_to_fit" class="fn">shrink_to_fit</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Discards as much additional capacity as possible.</p>
<h5 id="examples-20"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-20">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(<span class="number">100</span>);

<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">100</span>);
heap.shrink_to_fit();
<span class="macro">assert!</span>(heap.capacity() == <span class="number">0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap:+BinaryHeap%3Ci32%3E+=+BinaryHeap::with_capacity(100);%0A++++%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.shrink_to_fit();%0A++++assert!(heap.capacity()+==+0);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shrink_to" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.56.0">1.56.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1279">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.shrink_to" class="fn">shrink_to</a>(&amp;mut self, min_capacity: <a class="primitive" href="../primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Discards capacity with a lower bound.</p>
<p>The capacity will remain at least as large as both the length
and the supplied value.</p>
<p>If the current capacity is less than the lower limit, this is a no-op.</p>
<h5 id="examples-21"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-21">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(<span class="number">100</span>);

<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">100</span>);
heap.shrink_to(<span class="number">10</span>);
<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap:+BinaryHeap%3Ci32%3E+=+BinaryHeap::with_capacity(100);%0A++++%0A++++assert!(heap.capacity()+%3E=+100);%0A++++heap.shrink_to(10);%0A++++assert!(heap.capacity()+%3E=+10);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_slice" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1300">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.as_slice" class="fn">as_slice</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.slice.html">[T]</a></h4></section></summary><div class="docblock"><p>Returns a slice of all values in the underlying vector, in arbitrary
order.</p>
<h5 id="examples-22"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-22">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">use </span>std::io::{<span class="self">self</span>, Write};

<span class="kw">let </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);

io::sink().write(heap.as_slice()).unwrap();</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++use+std::io::%7Bself,+Write%7D;%0A++++%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5,+6,+7%5D);%0A++++%0A++++io::sink().write(heap.as_slice()).unwrap();%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_vec" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1323">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.into_vec" class="fn">into_vec</a>(self) -&gt; <a class="struct" href="../vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;T, A&gt;</h4></section></summary><div class="docblock"><p>Consumes the <code>BinaryHeap</code> and returns the underlying vector
in arbitrary order.</p>
<h5 id="examples-23"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-23">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);
<span class="kw">let </span>vec = heap.into_vec();

<span class="comment">// Will print in some order
</span><span class="kw">for </span>x <span class="kw">in </span>vec {
    <span class="macro">println!</span>(<span class="string">"{x}"</span>);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4,+5,+6,+7%5D);%0A++++let+vec+=+heap.into_vec();%0A++++%0A++++//+Will+print+in+some+order%0A++++for+x+in+vec+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.allocator" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1330">Source</a><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.allocator" class="fn">allocator</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.reference.html">&amp;A</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ð¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</span></div></span></summary><div class="docblock"><p>Returns a reference to the underlying allocator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1349">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of the binary heap.</p>
<h5 id="examples-24"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-24">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert_eq!</span>(heap.len(), <span class="number">2</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert_eq!(heap.len(),+2);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1373">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the binary heap is empty.</p>
<h5 id="examples-25"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-25">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();

<span class="macro">assert!</span>(heap.is_empty());

heap.push(<span class="number">3</span>);
heap.push(<span class="number">5</span>);
heap.push(<span class="number">1</span>);

<span class="macro">assert!</span>(!heap.is_empty());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::new();%0A++++%0A++++assert!(heap.is_empty());%0A++++%0A++++heap.push(3);%0A++++heap.push(5);%0A++++heap.push(1);%0A++++%0A++++assert!(!heap.is_empty());%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.drain" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1402">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.drain" class="fn">drain</a>(&amp;mut self) -&gt; <a class="struct" href="binary_heap/struct.Drain.html" title="struct std::collections::binary_heap::Drain">Drain</a>&lt;'_, T, A&gt; <a href="struct.BinaryHeap.html#" class="tooltip" data-notable-ty="Drain&lt;&#39;_, T, A&gt;">â</a></h4></section></summary><div class="docblock"><p>Clears the binary heap, returning an iterator over the removed elements
in arbitrary order. If the iterator is dropped before being fully
consumed, it drops the remaining elements in arbitrary order.</p>
<p>The returned iterator keeps a mutable borrow on the heap to optimize
its implementation.</p>
<h5 id="examples-26"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-26">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert!</span>(!heap.is_empty());

<span class="kw">for </span>x <span class="kw">in </span>heap.drain() {
    <span class="macro">println!</span>(<span class="string">"{x}"</span>);
}

<span class="macro">assert!</span>(heap.is_empty());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert!(!heap.is_empty());%0A++++%0A++++for+x+in+heap.drain()+%7B%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A++++%0A++++assert!(heap.is_empty());%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1423">Source</a></span><h4 class="code-header">pub fn <a href="struct.BinaryHeap.html#method.clear" class="fn">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Drops all items from the binary heap.</p>
<h5 id="examples-27"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-27">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert!</span>(!heap.is_empty());

heap.clear();

<span class="macro">assert!</span>(heap.is_empty());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+mut+heap+=+BinaryHeap::from(%5B1,+3%5D);%0A++++%0A++++assert!(!heap.is_empty());%0A++++%0A++++heap.clear();%0A++++%0A++++assert!(heap.is_empty());%0A%7D&amp;edition=2024"></a></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="struct.BinaryHeap.html#trait-implementations" class="anchor">Â§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-BinaryHeap%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#452">Source</a></span><a href="struct.BinaryHeap.html#impl-Clone-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    T: <a class="trait" href="../clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a> + <a class="trait" href="../clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#463">Source</a><a href="struct.BinaryHeap.html#method.clone_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;<a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;)</h4></section></summary><div class="docblock"><p>Overwrites the contents of <code>self</code> with a clone of the contents of <code>source</code>.</p>
<p>This method is preferred over simply assigning <code>source.clone()</code> to <code>self</code>,
as it avoids reallocation if possible.</p>
<p>See <a href="../vec/struct.Vec.html#method.clone_from" title="method std::vec::Vec::clone_from"><code>Vec::clone_from()</code></a> for more details.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#453">Source</a><a href="struct.BinaryHeap.html#method.clone" class="anchor">Â§</a><h4 class="code-header">fn <a href="../clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="../clone/trait.Clone.html#tymethod.clone">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-BinaryHeap%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#478">Source</a></span><a href="struct.BinaryHeap.html#impl-Debug-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    T: <a class="trait" href="../fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a>,
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#479">Source</a><a href="struct.BinaryHeap.html#method.fmt" class="anchor">Â§</a><h4 class="code-header">fn <a href="../fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit.html">()</a>, <a class="struct" href="../fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="../fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-BinaryHeap%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#469">Source</a></span><a href="struct.BinaryHeap.html#impl-Default-for-BinaryHeap%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../default/trait.Default.html" title="trait std::default::Default">Default</a> for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#472">Source</a><a href="struct.BinaryHeap.html#method.default" class="anchor">Â§</a><h4 class="code-header">fn <a href="../default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates an empty <code>BinaryHeap&lt;T&gt;</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3C%26T%3E-for-BinaryHeap%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1961">Source</a></span><a href="struct.BinaryHeap.html#impl-Extend%3C%26T%3E-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, T, A&gt; <a class="trait" href="../iter/trait.Extend.html" title="trait std::iter::Extend">Extend</a>&lt;<a class="primitive" href="../primitive.reference.html">&amp;'a T</a>&gt; for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    T: 'a + <a class="trait" href="../cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> + <a class="trait" href="../marker/trait.Copy.html" title="trait std::marker::Copy">Copy</a>,
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1962">Source</a><a href="struct.BinaryHeap.html#method.extend-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../iter/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class="where">where
    I: <a class="trait" href="../iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="../primitive.reference.html">&amp;'a T</a>&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="../iter/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1967">Source</a><a href="struct.BinaryHeap.html#method.extend_one-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../iter/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, _: <a class="primitive" href="../primitive.reference.html">&amp;'a T</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ð¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1972">Source</a><a href="struct.BinaryHeap.html#method.extend_reserve-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../iter/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ð¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Extend%3CT%3E-for-BinaryHeap%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1942">Source</a></span><a href="struct.BinaryHeap.html#impl-Extend%3CT%3E-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../iter/trait.Extend.html" title="trait std::iter::Extend">Extend</a>&lt;T&gt; for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    T: <a class="trait" href="../cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a>,
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extend" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1944">Source</a><a href="struct.BinaryHeap.html#method.extend" class="anchor">Â§</a><h4 class="code-header">fn <a href="../iter/trait.Extend.html#tymethod.extend" class="fn">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class="where">where
    I: <a class="trait" href="../iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a href="../iter/trait.Extend.html#tymethod.extend">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.extend_one" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1950">Source</a><a href="struct.BinaryHeap.html#method.extend_one" class="anchor">Â§</a><h4 class="code-header">fn <a href="../iter/trait.Extend.html#method.extend_one" class="fn">extend_one</a>(&amp;mut self, item: T)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ð¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class="toggle method-toggle" open><summary><section id="method.extend_reserve" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1955">Source</a><a href="struct.BinaryHeap.html#method.extend_reserve" class="anchor">Â§</a><h4 class="code-header">fn <a href="../iter/trait.Extend.html#method.extend_reserve" class="fn">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ð¬</span><span>This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.Extend.html#method.extend_reserve">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%5BT;+N%5D%3E-for-BinaryHeap%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.56.0">1.56.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1870">Source</a></span><a href="struct.BinaryHeap.html#impl-From%3C%5BT;+N%5D%3E-for-BinaryHeap%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, const N: <a class="primitive" href="../primitive.usize.html">usize</a>&gt; <a class="trait" href="../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="../primitive.array.html">[T; N]</a>&gt; for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1880">Source</a><a href="struct.BinaryHeap.html#method.from-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../convert/trait.From.html#tymethod.from" class="fn">from</a>(arr: <a class="primitive" href="../primitive.array.html">[T; N]</a>) -&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class="docblock">
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;

<span class="kw">let </span><span class="kw-2">mut </span>h1 = BinaryHeap::from([<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="kw">let </span><span class="kw-2">mut </span>h2: BinaryHeap&lt;<span class="kw">_</span>&gt; = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>].into();
<span class="kw">while let </span><span class="prelude-val">Some</span>((a, b)) = h1.pop().zip(h2.pop()) {
    <span class="macro">assert_eq!</span>(a, b);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++%0A++++let+mut+h1+=+BinaryHeap::from(%5B1,+4,+2,+3%5D);%0A++++let+mut+h2:+BinaryHeap%3C_%3E+=+%5B1,+4,+2,+3%5D.into();%0A++++while+let+Some((a,+b))+=+h1.pop().zip(h2.pop())+%7B%0A++++++++assert_eq!(a,+b);%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CBinaryHeap%3CT,+A%3E%3E-for-Vec%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1886">Source</a></span><a href="struct.BinaryHeap.html#impl-From%3CBinaryHeap%3CT,+A%3E%3E-for-Vec%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;&gt; for <a class="struct" href="../vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;T, A&gt;<div class="where">where
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1891">Source</a><a href="struct.BinaryHeap.html#method.from-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="../convert/trait.From.html#tymethod.from" class="fn">from</a>(heap: <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;) -&gt; <a class="struct" href="../vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;T, A&gt;</h4></section></summary><div class="docblock"><p>Converts a <code>BinaryHeap&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.</p>
<p>This conversion requires no data movement or allocation, and has
constant time complexity.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CVec%3CT,+A%3E%3E-for-BinaryHeap%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1858">Source</a></span><a href="struct.BinaryHeap.html#impl-From%3CVec%3CT,+A%3E%3E-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="struct" href="../vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;T, A&gt;&gt; for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    T: <a class="trait" href="../cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a>,
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1862">Source</a><a href="struct.BinaryHeap.html#method.from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../convert/trait.From.html#tymethod.from" class="fn">from</a>(vec: <a class="struct" href="../vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;T, A&gt;) -&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;</h4></section></summary><div class="docblock"><p>Converts a <code>Vec&lt;T&gt;</code> into a <code>BinaryHeap&lt;T&gt;</code>.</p>
<p>This conversion happens in-place, and has <em>O</em>(<em>n</em>) time complexity.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromIterator%3CT%3E-for-BinaryHeap%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1897">Source</a></span><a href="struct.BinaryHeap.html#impl-FromIterator%3CT%3E-for-BinaryHeap%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;T&gt; for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1898">Source</a><a href="struct.BinaryHeap.html#method.from_iter" class="anchor">Â§</a><h4 class="code-header">fn <a href="../iter/trait.FromIterator.html#tymethod.from_iter" class="fn">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;<div class="where">where
    I: <a class="trait" href="../iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a href="../iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26BinaryHeap%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1932">Source</a></span><a href="struct.BinaryHeap.html#impl-IntoIterator-for-%26BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, T, A&gt; <a class="trait" href="../iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Item-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1933">Source</a><a href="struct.BinaryHeap.html#associatedtype.Item-1" class="anchor">Â§</a><h4 class="code-header">type <a href="../iter/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="../primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1934">Source</a><a href="struct.BinaryHeap.html#associatedtype.IntoIter-1" class="anchor">Â§</a><h4 class="code-header">type <a href="../iter/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="binary_heap/struct.Iter.html" title="struct std::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1936">Source</a><a href="struct.BinaryHeap.html#method.into_iter-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../iter/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; <a class="struct" href="binary_heap/struct.Iter.html" title="struct std::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt; <a href="struct.BinaryHeap.html#" class="tooltip" data-notable-ty="Iter&lt;&#39;a, T&gt;">â</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="../iter/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-BinaryHeap%3CT,+A%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1904">Source</a></span><a href="struct.BinaryHeap.html#impl-IntoIterator-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a> for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    A: <a class="trait" href="../alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1926">Source</a><a href="struct.BinaryHeap.html#method.into_iter" class="anchor">Â§</a><h4 class="code-header">fn <a href="../iter/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; <a class="struct" href="binary_heap/struct.IntoIter.html" title="struct std::collections::binary_heap::IntoIter">IntoIter</a>&lt;T, A&gt; <a href="struct.BinaryHeap.html#" class="tooltip" data-notable-ty="IntoIter&lt;T, A&gt;">â</a></h4></section></summary><div class="docblock"><p>Creates a consuming iterator, that is, one that moves each value out of
the binary heap in arbitrary order. The binary heap cannot be used
after calling this.</p>
<h5 id="examples-28"><a class="doc-anchor" href="struct.BinaryHeap.html#examples-28">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);

<span class="comment">// Print 1, 2, 3, 4 in arbitrary order
</span><span class="kw">for </span>x <span class="kw">in </span>heap.into_iter() {
    <span class="comment">// x has type i32, not &amp;i32
    </span><span class="macro">println!</span>(<span class="string">"{x}"</span>);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::collections::BinaryHeap;%0A++++let+heap+=+BinaryHeap::from(%5B1,+2,+3,+4%5D);%0A++++%0A++++//+Print+1,+2,+3,+4+in+arbitrary+order%0A++++for+x+in+heap.into_iter()+%7B%0A++++++++//+x+has+type+i32,+not+%26i32%0A++++++++println!(%22%7Bx%7D%22);%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1905">Source</a><a href="struct.BinaryHeap.html#associatedtype.Item" class="anchor">Â§</a><h4 class="code-header">type <a href="../iter/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = T</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap/mod.rs.html#1906">Source</a><a href="struct.BinaryHeap.html#associatedtype.IntoIter" class="anchor">Â§</a><h4 class="code-header">type <a href="../iter/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="binary_heap/struct.IntoIter.html" title="struct std::collections::binary_heap::IntoIter">IntoIter</a>&lt;T, A&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="struct.BinaryHeap.html#synthetic-implementations" class="anchor">Â§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-BinaryHeap%3CT,+A%3E" class="impl"><a href="struct.BinaryHeap.html#impl-Freeze-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../marker/trait.Freeze.html" title="trait std::marker::Freeze">Freeze</a> for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    A: <a class="trait" href="../marker/trait.Freeze.html" title="trait std::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-BinaryHeap%3CT,+A%3E" class="impl"><a href="struct.BinaryHeap.html#impl-RefUnwindSafe-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    A: <a class="trait" href="../panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,
    T: <a class="trait" href="../panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-BinaryHeap%3CT,+A%3E" class="impl"><a href="struct.BinaryHeap.html#impl-Send-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    A: <a class="trait" href="../marker/trait.Send.html" title="trait std::marker::Send">Send</a>,
    T: <a class="trait" href="../marker/trait.Send.html" title="trait std::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-BinaryHeap%3CT,+A%3E" class="impl"><a href="struct.BinaryHeap.html#impl-Sync-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    A: <a class="trait" href="../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a>,
    T: <a class="trait" href="../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-BinaryHeap%3CT,+A%3E" class="impl"><a href="struct.BinaryHeap.html#impl-Unpin-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    A: <a class="trait" href="../marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a>,
    T: <a class="trait" href="../marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-BinaryHeap%3CT,+A%3E" class="impl"><a href="struct.BinaryHeap.html#impl-UnwindSafe-for-BinaryHeap%3CT,+A%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="../panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;<div class="where">where
    A: <a class="trait" href="../panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a>,
    T: <a class="trait" href="../panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="struct.BinaryHeap.html#blanket-implementations" class="anchor">Â§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#138">Source</a><a href="struct.BinaryHeap.html#impl-Any-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../any/trait.Any.html" title="trait std::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#139">Source</a><a href="struct.BinaryHeap.html#method.type_id" class="anchor">Â§</a><h4 class="code-header">fn <a href="../any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="../any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#209">Source</a><a href="struct.BinaryHeap.html#impl-Borrow%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211">Source</a><a href="struct.BinaryHeap.html#method.borrow" class="anchor">Â§</a><h4 class="code-header">fn <a href="../borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217">Source</a><a href="struct.BinaryHeap.html#impl-BorrowMut%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218">Source</a><a href="struct.BinaryHeap.html#method.borrow_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/clone.rs.html#441">Source</a><a href="struct.BinaryHeap.html#impl-CloneToUninit-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../clone/trait.CloneToUninit.html" title="trait std::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="../clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/clone.rs.html#443">Source</a><a href="struct.BinaryHeap.html#method.clone_to_uninit" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="../clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="../primitive.pointer.html">*mut </a><a class="primitive" href="../primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ð¬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/126799">#126799</a>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="../clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#767">Source</a><a href="struct.BinaryHeap.html#impl-From%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#770">Source</a><a href="struct.BinaryHeap.html#method.from-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="../convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#750-752">Source</a><a href="struct.BinaryHeap.html#impl-Into%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#760">Source</a><a href="struct.BinaryHeap.html#method.into" class="anchor">Â§</a><h4 class="code-header">fn <a href="../convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#82-84">Source</a><a href="struct.BinaryHeap.html#impl-ToOwned-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="../clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#86">Source</a><a href="struct.BinaryHeap.html#associatedtype.Owned" class="anchor">Â§</a><h4 class="code-header">type <a href="../borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#87">Source</a><a href="struct.BinaryHeap.html#method.to_owned" class="anchor">Â§</a><h4 class="code-header">fn <a href="../borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="../borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#91">Source</a><a href="struct.BinaryHeap.html#method.clone_into" class="anchor">Â§</a><h4 class="code-header">fn <a href="../borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="../primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="../borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#806-808">Source</a><a href="struct.BinaryHeap.html#impl-TryFrom%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#810">Source</a><a href="struct.BinaryHeap.html#associatedtype.Error-1" class="anchor">Â§</a><h4 class="code-header">type <a href="../convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#813">Source</a><a href="struct.BinaryHeap.html#method.try_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#791-793">Source</a><a href="struct.BinaryHeap.html#impl-TryInto%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#795">Source</a><a href="struct.BinaryHeap.html#associatedtype.Error" class="anchor">Â§</a><h4 class="code-header">type <a href="../convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#798">Source</a><a href="struct.BinaryHeap.html#method.try_into" class="anchor">Â§</a><h4 class="code-header">fn <a href="../convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"Drain<'_, T, A>":"<h3>Notable traits for <code><a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.Drain.html\&quot;" title=\"struct std::collections::binary_heap::Drain\">Drain</a>&lt;'_, T, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, A&gt; <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html\&quot;" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.Drain.html\&quot;" title=\"struct std::collections::binary_heap::Drain\">Drain</a>&lt;'_, T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../alloc/trait.Allocator.html\&quot;" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></div><div class=\"where\">    type <a href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html#associatedtype.Item\"" class=\"associatedtype\">Item</a> = T;</div>","DrainSorted<'_, T, A>":"<h3>Notable traits for <code><a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.DrainSorted.html\&quot;" title=\"struct std::collections::binary_heap::DrainSorted\">DrainSorted</a>&lt;'_, T, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, A&gt; <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html\&quot;" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.DrainSorted.html\&quot;" title=\"struct std::collections::binary_heap::DrainSorted\">DrainSorted</a>&lt;'_, T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../cmp/trait.Ord.html\&quot;" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../alloc/trait.Allocator.html\&quot;" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></div><div class=\"where\">    type <a href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html#associatedtype.Item\"" class=\"associatedtype\">Item</a> = T;</div>","IntoIter<T, A>":"<h3>Notable traits for <code><a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.IntoIter.html\&quot;" title=\"struct std::collections::binary_heap::IntoIter\">IntoIter</a>&lt;T, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, A&gt; <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html\&quot;" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.IntoIter.html\&quot;" title=\"struct std::collections::binary_heap::IntoIter\">IntoIter</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../alloc/trait.Allocator.html\&quot;" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></div><div class=\"where\">    type <a href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html#associatedtype.Item\"" class=\"associatedtype\">Item</a> = T;</div>","IntoIterSorted<T, A>":"<h3>Notable traits for <code><a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.IntoIterSorted.html\&quot;" title=\"struct std::collections::binary_heap::IntoIterSorted\">IntoIterSorted</a>&lt;T, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, A&gt; <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html\&quot;" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.IntoIterSorted.html\&quot;" title=\"struct std::collections::binary_heap::IntoIterSorted\">IntoIterSorted</a>&lt;T, A&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../cmp/trait.Ord.html\&quot;" title=\"trait std::cmp::Ord\">Ord</a>,\n    A: <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../alloc/trait.Allocator.html\&quot;" title=\"trait std::alloc::Allocator\">Allocator</a>,</div></div><div class=\"where\">    type <a href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html#associatedtype.Item\"" class=\"associatedtype\">Item</a> = T;</div>","Iter<'_, T>":"<h3>Notable traits for <code><a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.Iter.html\&quot;" title=\"struct std::collections::binary_heap::Iter\">Iter</a>&lt;'a, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, T&gt; <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html\&quot;" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.Iter.html\&quot;" title=\"struct std::collections::binary_heap::Iter\">Iter</a>&lt;'a, T&gt;</div><div class=\"where\">    type <a href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html#associatedtype.Item\"" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href="https://doc.rust-lang.org/std/collections/\&quot;../primitive.reference.html\&quot;">&amp;'a T</a>;</div>","Iter<'a, T>":"<h3>Notable traits for <code><a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.Iter.html\&quot;" title=\"struct std::collections::binary_heap::Iter\">Iter</a>&lt;'a, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, T&gt; <a class=\"trait\" href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html\&quot;" title=\"trait std::iter::Iterator\">Iterator</a> for <a class=\"struct\" href="https://doc.rust-lang.org/std/collections/\&quot;binary_heap/struct.Iter.html\&quot;" title=\"struct std::collections::binary_heap::Iter\">Iter</a>&lt;'a, T&gt;</div><div class=\"where\">    type <a href="https://doc.rust-lang.org/std/collections/\&quot;../iter/trait.Iterator.html#associatedtype.Item\"" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href="https://doc.rust-lang.org/std/collections/\&quot;../primitive.reference.html\&quot;">&amp;'a T</a>;</div>"}</script></section></div></main></body></html>