<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Cooperatively gives up a timeslice to the OS scheduler."><title>yield_now in std::thread - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="https://doc.rust-lang.org/static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="1.88.0" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items1.88.0.js"></script><script defer src="../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="https://doc.rust-lang.org/static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../index.html"><img class="rust-logo" src="../../static.files/rust-logo-9a9549ea.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../index.html"><img class="rust-logo" src="../../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../index.html">std</a><span class="version">1.88.0</span></h2></div><div class="version">(6b00bc388	2025-06-23)</div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="fn.yield_now.html#">yield_<wbr>now</a></h2><h3><a href="fn.yield_now.html#">Sections</a></h3><ul class="block top-toc"><li><a href="fn.yield_now.html#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In std::<wbr>thread</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">std</a>::<wbr><a href="index.html">thread</a></div><h1>Function <span class="fn">yield_now</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/src/std/thread/mod.rs.html#765-767">Source</a> </span></div><pre class="rust item-decl"><code>pub fn yield_now()</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Cooperatively gives up a timeslice to the OS scheduler.</p>
<p>This calls the underlying OS scheduler’s yield primitive, signaling
that the calling thread is willing to give up its remaining timeslice
so that the OS may schedule other threads on the CPU.</p>
<p>A drawback of yielding in a loop is that if the OS does not have any
other ready threads to run on the current CPU, the thread will effectively
busy-wait, which wastes CPU time and energy.</p>
<p>Therefore, when waiting for events of interest, a programmer’s first
choice should be to use synchronization devices such as <a href="../sync/mpsc/index.html" title="mod std::sync::mpsc"><code>channel</code></a>s,
<a href="../sync/struct.Condvar.html" title="struct std::sync::Condvar"><code>Condvar</code></a>s, <a href="../sync/struct.Mutex.html" title="struct std::sync::Mutex"><code>Mutex</code></a>es or <a href="struct.JoinHandle.html#method.join" title="method std::thread::JoinHandle::join"><code>join</code></a> since these primitives are
implemented in a blocking manner, giving up the CPU until the event
of interest has occurred which avoids repeated yielding.</p>
<p><code>yield_now</code> should thus be used only rarely, mostly in situations where
repeated polling is required because there is no other suitable way to
learn when an event of interest has occurred.</p>
<h2 id="examples"><a class="doc-anchor" href="fn.yield_now.html#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::thread;

thread::yield_now();</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::thread;%0A++++%0A++++thread::yield_now();%0A%7D&amp;edition=2024"></a></div>
</div></details></section></div></main></body></html>