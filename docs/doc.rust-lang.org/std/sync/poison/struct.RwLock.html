<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A reader-writer lock"><title>RwLock in std::sync::poison - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="https://doc.rust-lang.org/static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="1.88.0" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items1.88.0.js"></script><script defer src="../../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="https://doc.rust-lang.org/static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../index.html"><img class="rust-logo" src="../../../static.files/rust-logo-9a9549ea.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../index.html"><img class="rust-logo" src="../../../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../../index.html">std</a><span class="version">1.88.0</span></h2></div><div class="version">(6b00bc388	2025-06-23)</div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="struct.RwLock.html#">RwLock</a></h2><h3><a href="struct.RwLock.html#">Sections</a></h3><ul class="block top-toc"><li><a href="struct.RwLock.html#poisoning" title="Poisoning">Poisoning</a></li><li><a href="struct.RwLock.html#examples" title="Examples">Examples</a></li></ul><h3><a href="struct.RwLock.html#implementations">Methods</a></h3><ul class="block method"><li><a href="struct.RwLock.html#method.clear_poison" title="clear_poison">clear_poison</a></li><li><a href="struct.RwLock.html#method.get_cloned" title="get_cloned">get_cloned</a></li><li><a href="struct.RwLock.html#method.get_mut" title="get_mut">get_mut</a></li><li><a href="struct.RwLock.html#method.into_inner" title="into_inner">into_inner</a></li><li><a href="struct.RwLock.html#method.is_poisoned" title="is_poisoned">is_poisoned</a></li><li><a href="struct.RwLock.html#method.new" title="new">new</a></li><li><a href="struct.RwLock.html#method.read" title="read">read</a></li><li><a href="struct.RwLock.html#method.replace" title="replace">replace</a></li><li><a href="struct.RwLock.html#method.set" title="set">set</a></li><li><a href="struct.RwLock.html#method.try_read" title="try_read">try_read</a></li><li><a href="struct.RwLock.html#method.try_write" title="try_write">try_write</a></li><li><a href="struct.RwLock.html#method.write" title="write">write</a></li></ul><h3><a href="struct.RwLock.html#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="struct.RwLock.html#impl-Debug-for-RwLock%3CT%3E" title="Debug">Debug</a></li><li><a href="struct.RwLock.html#impl-Default-for-RwLock%3CT%3E" title="Default">Default</a></li><li><a href="struct.RwLock.html#impl-From%3CT%3E-for-RwLock%3CT%3E" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="struct.RwLock.html#impl-RefUnwindSafe-for-RwLock%3CT%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="struct.RwLock.html#impl-Send-for-RwLock%3CT%3E" title="Send">Send</a></li><li><a href="struct.RwLock.html#impl-Sync-for-RwLock%3CT%3E" title="Sync">Sync</a></li><li><a href="struct.RwLock.html#impl-UnwindSafe-for-RwLock%3CT%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="struct.RwLock.html#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="struct.RwLock.html#impl-Freeze-for-RwLock%3CT%3E" title="!Freeze">!Freeze</a></li><li><a href="struct.RwLock.html#impl-Unpin-for-RwLock%3CT%3E" title="Unpin">Unpin</a></li></ul><h3><a href="struct.RwLock.html#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="struct.RwLock.html#impl-Any-for-T" title="Any">Any</a></li><li><a href="struct.RwLock.html#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="struct.RwLock.html#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="struct.RwLock.html#impl-From%3C!%3E-for-T" title="From&#60;!&#62;">From&#60;!&#62;</a></li><li><a href="struct.RwLock.html#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="struct.RwLock.html#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="struct.RwLock.html#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="struct.RwLock.html#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In std::<wbr>sync::<wbr>poison</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">std</a>::<wbr><a href="../index.html">sync</a>::<wbr><a href="index.html">poison</a></div><h1>Struct <span class="struct">RwLock</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#80-84">Source</a> </span></div><pre class="rust item-decl"><code>pub struct RwLock&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>sync_poison_mod</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/134646">#134646</a>)</span></div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A reader-writer lock</p>
<p>This type of lock allows a number of readers or at most one writer at any
point in time. The write portion of this lock typically allows modification
of the underlying data (exclusive access) and the read portion of this lock
typically allows for read-only access (shared access).</p>
<p>In comparison, a <a href="../struct.Mutex.html" title="struct std::sync::Mutex"><code>Mutex</code></a> does not distinguish between readers or writers
that acquire the lock, therefore blocking any threads waiting for the lock to
become available. An <code>RwLock</code> will allow any number of readers to acquire the
lock as long as a writer is not holding the lock.</p>
<p>The priority policy of the lock is dependent on the underlying operating
systemâ€™s implementation, and this type does not guarantee that any
particular policy will be used. In particular, a writer which is waiting to
acquire the lock in <code>write</code> might or might not block concurrent calls to
<code>read</code>, e.g.:</p>
<details><summary>Potential deadlock example</summary>
<div class="example-wrap"><pre class="language-text"><code>// Thread 1              |  // Thread 2
let _rg1 = lock.read();  |
                         |  // will block
                         |  let _wg = lock.write();
// may deadlock          |
let _rg2 = lock.read();  |</code></pre></div></details>
<p>The type parameter <code>T</code> represents the data that this lock protects. It is
required that <code>T</code> satisfies <a href="../../marker/trait.Send.html" title="trait std::marker::Send"><code>Send</code></a> to be shared across threads and
<a href="../../marker/trait.Sync.html" title="trait std::marker::Sync"><code>Sync</code></a> to allow concurrent access through readers. The RAII guards
returned from the locking methods implement <a href="../../ops/trait.Deref.html" title="trait std::ops::Deref"><code>Deref</code></a> (and <a href="../../ops/trait.DerefMut.html" title="trait std::ops::DerefMut"><code>DerefMut</code></a>
for the <code>write</code> methods) to allow access to the content of the lock.</p>
<h2 id="poisoning"><a class="doc-anchor" href="struct.RwLock.html#poisoning">Â§</a>Poisoning</h2>
<p>An <code>RwLock</code>, like <a href="../struct.Mutex.html" title="struct std::sync::Mutex"><code>Mutex</code></a>, will become poisoned on a panic. Note, however,
that an <code>RwLock</code> may only be poisoned if a panic occurs while it is locked
exclusively (write mode). If a panic occurs in any reader, then the lock
will not be poisoned.</p>
<h2 id="examples"><a class="doc-anchor" href="struct.RwLock.html#examples">Â§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::RwLock;

<span class="kw">let </span>lock = RwLock::new(<span class="number">5</span>);

<span class="comment">// many reader locks can be held at once
</span>{
    <span class="kw">let </span>r1 = lock.read().unwrap();
    <span class="kw">let </span>r2 = lock.read().unwrap();
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>r1, <span class="number">5</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>r2, <span class="number">5</span>);
} <span class="comment">// read locks are dropped at this point

// only one write lock may be held, however
</span>{
    <span class="kw">let </span><span class="kw-2">mut </span>w = lock.write().unwrap();
    <span class="kw-2">*</span>w += <span class="number">1</span>;
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>w, <span class="number">6</span>);
} <span class="comment">// write lock is dropped here</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(5);%0A++++%0A++++//+many+reader+locks+can+be+held+at+once%0A++++%7B%0A++++++++let+r1+=+lock.read().unwrap();%0A++++++++let+r2+=+lock.read().unwrap();%0A++++++++assert_eq!(*r1,+5);%0A++++++++assert_eq!(*r2,+5);%0A++++%7D+//+read+locks+are+dropped+at+this+point%0A++++%0A++++//+only+one+write+lock+may+be+held,+however%0A++++%7B%0A++++++++let+mut+w+=+lock.write().unwrap();%0A++++++++*w+%2B=+1;%0A++++++++assert_eq!(*w,+6);%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="struct.RwLock.html#implementations" class="anchor">Â§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-RwLock%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#208-321">Source</a><a href="struct.RwLock.html#impl-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.63.0">1.0.0 (const: 1.63.0)</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#221-223">Source</a></span><h4 class="code-header">pub const fn <a href="struct.RwLock.html#method.new" class="fn">new</a>(t: T) -&gt; <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked.</p>
<h5 id="examples-1"><a class="doc-anchor" href="struct.RwLock.html#examples-1">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::RwLock;

<span class="kw">let </span>lock = RwLock::new(<span class="number">5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(5);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_cloned" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#245-253">Source</a><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.get_cloned" class="fn">get_cloned</a>(&amp;self) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, <a class="struct" href="../struct.PoisonError.html" title="struct std::sync::PoisonError">PoisonError</a>&lt;<a class="primitive" href="../../primitive.unit.html">()</a>&gt;&gt;<div class="where">where
    T: <a class="trait" href="../../clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span></div></span></summary><div class="docblock"><p>Returns the contained value by cloning it.</p>
<h5 id="errors"><a class="doc-anchor" href="struct.RwLock.html#errors">Â§</a>Errors</h5>
<p>This function will return an error if the <code>RwLock</code> is poisoned. An
<code>RwLock</code> is poisoned whenever a writer panics while holding an exclusive
lock.</p>
<h5 id="examples-2"><a class="doc-anchor" href="struct.RwLock.html#examples-2">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(lock_value_accessors)]

</span><span class="kw">use </span>std::sync::RwLock;

<span class="kw">let </span><span class="kw-2">mut </span>lock = RwLock::new(<span class="number">7</span>);

<span class="macro">assert_eq!</span>(lock.get_cloned().unwrap(), <span class="number">7</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(lock_value_accessors)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::RwLock;%0A++++%0A++++let+mut+lock+=+RwLock::new(7);%0A++++%0A++++assert_eq!(lock.get_cloned().unwrap(),+7);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#277-292">Source</a><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.set" class="fn">set</a>(&amp;self, value: T) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.unit.html">()</a>, <a class="struct" href="../struct.PoisonError.html" title="struct std::sync::PoisonError">PoisonError</a>&lt;T&gt;&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span></div></span></summary><div class="docblock"><p>Sets the contained value.</p>
<h5 id="errors-1"><a class="doc-anchor" href="struct.RwLock.html#errors-1">Â§</a>Errors</h5>
<p>This function will return an error containing the provided <code>value</code> if
the <code>RwLock</code> is poisoned. An <code>RwLock</code> is poisoned whenever a writer
panics while holding an exclusive lock.</p>
<h5 id="examples-3"><a class="doc-anchor" href="struct.RwLock.html#examples-3">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(lock_value_accessors)]

</span><span class="kw">use </span>std::sync::RwLock;

<span class="kw">let </span><span class="kw-2">mut </span>lock = RwLock::new(<span class="number">7</span>);

<span class="macro">assert_eq!</span>(lock.get_cloned().unwrap(), <span class="number">7</span>);
lock.set(<span class="number">11</span>).unwrap();
<span class="macro">assert_eq!</span>(lock.get_cloned().unwrap(), <span class="number">11</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(lock_value_accessors)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::RwLock;%0A++++%0A++++let+mut+lock+=+RwLock::new(7);%0A++++%0A++++assert_eq!(lock.get_cloned().unwrap(),+7);%0A++++lock.set(11).unwrap();%0A++++assert_eq!(lock.get_cloned().unwrap(),+11);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#315-320">Source</a><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.replace" class="fn">replace</a>(&amp;self, value: T) -&gt; <a class="type" href="../type.LockResult.html" title="type std::sync::LockResult">LockResult</a>&lt;T&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span></div></span></summary><div class="docblock"><p>Replaces the contained value with <code>value</code>, and returns the old contained value.</p>
<h5 id="errors-2"><a class="doc-anchor" href="struct.RwLock.html#errors-2">Â§</a>Errors</h5>
<p>This function will return an error containing the provided <code>value</code> if
the <code>RwLock</code> is poisoned. An <code>RwLock</code> is poisoned whenever a writer
panics while holding an exclusive lock.</p>
<h5 id="examples-4"><a class="doc-anchor" href="struct.RwLock.html#examples-4">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(lock_value_accessors)]

</span><span class="kw">use </span>std::sync::RwLock;

<span class="kw">let </span><span class="kw-2">mut </span>lock = RwLock::new(<span class="number">7</span>);

<span class="macro">assert_eq!</span>(lock.replace(<span class="number">11</span>).unwrap(), <span class="number">7</span>);
<span class="macro">assert_eq!</span>(lock.get_cloned().unwrap(), <span class="number">11</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(lock_value_accessors)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::RwLock;%0A++++%0A++++let+mut+lock+=+RwLock::new(7);%0A++++%0A++++assert_eq!(lock.replace(11).unwrap(),+7);%0A++++assert_eq!(lock.get_cloned().unwrap(),+11);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RwLock%3CT%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#323-637">Source</a><a href="struct.RwLock.html#impl-RwLock%3CT%3E-1" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.read" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#367-372">Source</a></span><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.read" class="fn">read</a>(&amp;self) -&gt; <a class="type" href="../type.LockResult.html" title="type std::sync::LockResult">LockResult</a>&lt;<a class="struct" href="../struct.RwLockReadGuard.html" title="struct std::sync::RwLockReadGuard">RwLockReadGuard</a>&lt;'_, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Locks this <code>RwLock</code> with shared read access, blocking the current thread
until it can be acquired.</p>
<p>The calling thread will be blocked until there are no more writers which
hold the lock. There may be other readers currently inside the lock when
this method returns. This method does not provide any guarantees with
respect to the ordering of whether contentious readers or writers will
acquire the lock first.</p>
<p>Returns an RAII guard which will release this threadâ€™s shared access
once it is dropped.</p>
<h5 id="errors-3"><a class="doc-anchor" href="struct.RwLock.html#errors-3">Â§</a>Errors</h5>
<p>This function will return an error if the <code>RwLock</code> is poisoned. An
<code>RwLock</code> is poisoned whenever a writer panics while holding an exclusive
lock. The failure will occur immediately after the lock has been
acquired. The acquired lock guard will be contained in the returned
error.</p>
<h5 id="panics"><a class="doc-anchor" href="struct.RwLock.html#panics">Â§</a>Panics</h5>
<p>This function might panic when called if the lock is already held by the current thread.</p>
<h5 id="examples-5"><a class="doc-anchor" href="struct.RwLock.html#examples-5">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::{Arc, RwLock};
<span class="kw">use </span>std::thread;

<span class="kw">let </span>lock = Arc::new(RwLock::new(<span class="number">1</span>));
<span class="kw">let </span>c_lock = Arc::clone(<span class="kw-2">&amp;</span>lock);

<span class="kw">let </span>n = lock.read().unwrap();
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>n, <span class="number">1</span>);

thread::spawn(<span class="kw">move </span>|| {
    <span class="kw">let </span>r = c_lock.read();
    <span class="macro">assert!</span>(r.is_ok());
}).join().unwrap();</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+RwLock%7D;%0A++++use+std::thread;%0A++++%0A++++let+lock+=+Arc::new(RwLock::new(1));%0A++++let+c_lock+=+Arc::clone(%26lock);%0A++++%0A++++let+n+=+lock.read().unwrap();%0A++++assert_eq!(*n,+1);%0A++++%0A++++thread::spawn(move+%7C%7C+%7B%0A++++++++let+r+=+c_lock.read();%0A++++++++assert!(r.is_ok());%0A++++%7D).join().unwrap();%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_read" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#413-421">Source</a></span><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.try_read" class="fn">try_read</a>(&amp;self) -&gt; <a class="type" href="../type.TryLockResult.html" title="type std::sync::TryLockResult">TryLockResult</a>&lt;<a class="struct" href="../struct.RwLockReadGuard.html" title="struct std::sync::RwLockReadGuard">RwLockReadGuard</a>&lt;'_, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Attempts to acquire this <code>RwLock</code> with shared read access.</p>
<p>If the access could not be granted at this time, then <code>Err</code> is returned.
Otherwise, an RAII guard is returned which will release the shared access
when it is dropped.</p>
<p>This function does not block.</p>
<p>This function does not provide any guarantees with respect to the ordering
of whether contentious readers or writers will acquire the lock first.</p>
<h5 id="errors-4"><a class="doc-anchor" href="struct.RwLock.html#errors-4">Â§</a>Errors</h5>
<p>This function will return the <a href="../enum.TryLockError.html#variant.Poisoned" title="variant std::sync::TryLockError::Poisoned"><code>Poisoned</code></a> error if the <code>RwLock</code> is
poisoned. An <code>RwLock</code> is poisoned whenever a writer panics while holding
an exclusive lock. <code>Poisoned</code> will only be returned if the lock would
have otherwise been acquired. An acquired lock guard will be contained
in the returned error.</p>
<p>This function will return the <a href="../enum.TryLockError.html#variant.WouldBlock" title="variant std::sync::TryLockError::WouldBlock"><code>WouldBlock</code></a> error if the <code>RwLock</code> could
not be acquired because it was already locked exclusively.</p>
<h5 id="examples-6"><a class="doc-anchor" href="struct.RwLock.html#examples-6">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::RwLock;

<span class="kw">let </span>lock = RwLock::new(<span class="number">1</span>);

<span class="kw">match </span>lock.try_read() {
    <span class="prelude-val">Ok</span>(n) =&gt; <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>n, <span class="number">1</span>),
    <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">unreachable!</span>(),
};</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(1);%0A++++%0A++++match+lock.try_read()+%7B%0A++++++++Ok(n)+=%3E+assert_eq!(*n,+1),%0A++++++++Err(_)+=%3E+unreachable!(),%0A++++%7D;%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#457-462">Source</a></span><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.write" class="fn">write</a>(&amp;self) -&gt; <a class="type" href="../type.LockResult.html" title="type std::sync::LockResult">LockResult</a>&lt;<a class="struct" href="../struct.RwLockWriteGuard.html" title="struct std::sync::RwLockWriteGuard">RwLockWriteGuard</a>&lt;'_, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Locks this <code>RwLock</code> with exclusive write access, blocking the current
thread until it can be acquired.</p>
<p>This function will not return while other writers or other readers
currently have access to the lock.</p>
<p>Returns an RAII guard which will drop the write access of this <code>RwLock</code>
when dropped.</p>
<h5 id="errors-5"><a class="doc-anchor" href="struct.RwLock.html#errors-5">Â§</a>Errors</h5>
<p>This function will return an error if the <code>RwLock</code> is poisoned. An
<code>RwLock</code> is poisoned whenever a writer panics while holding an exclusive
lock. An error will be returned when the lock is acquired. The acquired
lock guard will be contained in the returned error.</p>
<h5 id="panics-1"><a class="doc-anchor" href="struct.RwLock.html#panics-1">Â§</a>Panics</h5>
<p>This function might panic when called if the lock is already held by the current thread.</p>
<h5 id="examples-7"><a class="doc-anchor" href="struct.RwLock.html#examples-7">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::RwLock;

<span class="kw">let </span>lock = RwLock::new(<span class="number">1</span>);

<span class="kw">let </span><span class="kw-2">mut </span>n = lock.write().unwrap();
<span class="kw-2">*</span>n = <span class="number">2</span>;

<span class="macro">assert!</span>(lock.try_read().is_err());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(1);%0A++++%0A++++let+mut+n+=+lock.write().unwrap();%0A++++*n+=+2;%0A++++%0A++++assert!(lock.try_read().is_err());%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_write" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#504-512">Source</a></span><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.try_write" class="fn">try_write</a>(&amp;self) -&gt; <a class="type" href="../type.TryLockResult.html" title="type std::sync::TryLockResult">TryLockResult</a>&lt;<a class="struct" href="../struct.RwLockWriteGuard.html" title="struct std::sync::RwLockWriteGuard">RwLockWriteGuard</a>&lt;'_, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Attempts to lock this <code>RwLock</code> with exclusive write access.</p>
<p>If the lock could not be acquired at this time, then <code>Err</code> is returned.
Otherwise, an RAII guard is returned which will release the lock when
it is dropped.</p>
<p>This function does not block.</p>
<p>This function does not provide any guarantees with respect to the ordering
of whether contentious readers or writers will acquire the lock first.</p>
<h5 id="errors-6"><a class="doc-anchor" href="struct.RwLock.html#errors-6">Â§</a>Errors</h5>
<p>This function will return the <a href="../enum.TryLockError.html#variant.Poisoned" title="variant std::sync::TryLockError::Poisoned"><code>Poisoned</code></a> error if the <code>RwLock</code> is
poisoned. An <code>RwLock</code> is poisoned whenever a writer panics while holding
an exclusive lock. <code>Poisoned</code> will only be returned if the lock would
have otherwise been acquired. An acquired lock guard will be contained
in the returned error.</p>
<p>This function will return the <a href="../enum.TryLockError.html#variant.WouldBlock" title="variant std::sync::TryLockError::WouldBlock"><code>WouldBlock</code></a> error if the <code>RwLock</code> could
not be acquired because it was already locked exclusively.</p>
<h5 id="examples-8"><a class="doc-anchor" href="struct.RwLock.html#examples-8">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::RwLock;

<span class="kw">let </span>lock = RwLock::new(<span class="number">1</span>);

<span class="kw">let </span>n = lock.read().unwrap();
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>n, <span class="number">1</span>);

<span class="macro">assert!</span>(lock.try_write().is_err());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(1);%0A++++%0A++++let+n+=+lock.read().unwrap();%0A++++assert_eq!(*n,+1);%0A++++%0A++++assert!(lock.try_write().is_err());%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_poisoned" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#537-539">Source</a></span><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.is_poisoned" class="fn">is_poisoned</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Determines whether the lock is poisoned.</p>
<p>If another thread is active, the lock can still become poisoned at any
time. You should not trust a <code>false</code> value for program correctness
without additional synchronization.</p>
<h5 id="examples-9"><a class="doc-anchor" href="struct.RwLock.html#examples-9">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::{Arc, RwLock};
<span class="kw">use </span>std::thread;

<span class="kw">let </span>lock = Arc::new(RwLock::new(<span class="number">0</span>));
<span class="kw">let </span>c_lock = Arc::clone(<span class="kw-2">&amp;</span>lock);

<span class="kw">let _ </span>= thread::spawn(<span class="kw">move </span>|| {
    <span class="kw">let </span>_lock = c_lock.write().unwrap();
    <span class="macro">panic!</span>(); <span class="comment">// the lock gets poisoned
</span>}).join();
<span class="macro">assert_eq!</span>(lock.is_poisoned(), <span class="bool-val">true</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+RwLock%7D;%0A++++use+std::thread;%0A++++%0A++++let+lock+=+Arc::new(RwLock::new(0));%0A++++let+c_lock+=+Arc::clone(%26lock);%0A++++%0A++++let+_+=+thread::spawn(move+%7C%7C+%7B%0A++++++++let+_lock+=+c_lock.write().unwrap();%0A++++++++panic!();+//+the+lock+gets+poisoned%0A++++%7D).join();%0A++++assert_eq!(lock.is_poisoned(),+true);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear_poison" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.77.0">1.77.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#574-576">Source</a></span><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.clear_poison" class="fn">clear_poison</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Clear the poisoned state from a lock.</p>
<p>If the lock is poisoned, it will remain poisoned until this function is called. This allows
recovering from a poisoned state and marking that it has recovered. For example, if the
value is overwritten by a known-good value, then the lock can be marked as un-poisoned. Or
possibly, the value could be inspected to determine if it is in a consistent state, and if
so the poison is removed.</p>
<h5 id="examples-10"><a class="doc-anchor" href="struct.RwLock.html#examples-10">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::{Arc, RwLock};
<span class="kw">use </span>std::thread;

<span class="kw">let </span>lock = Arc::new(RwLock::new(<span class="number">0</span>));
<span class="kw">let </span>c_lock = Arc::clone(<span class="kw-2">&amp;</span>lock);

<span class="kw">let _ </span>= thread::spawn(<span class="kw">move </span>|| {
    <span class="kw">let </span>_lock = c_lock.write().unwrap();
    <span class="macro">panic!</span>(); <span class="comment">// the lock gets poisoned
</span>}).join();

<span class="macro">assert_eq!</span>(lock.is_poisoned(), <span class="bool-val">true</span>);
<span class="kw">let </span>guard = lock.write().unwrap_or_else(|<span class="kw-2">mut </span>e| {
    <span class="kw-2">**</span>e.get_mut() = <span class="number">1</span>;
    lock.clear_poison();
    e.into_inner()
});
<span class="macro">assert_eq!</span>(lock.is_poisoned(), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>guard, <span class="number">1</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::%7BArc,+RwLock%7D;%0A++++use+std::thread;%0A++++%0A++++let+lock+=+Arc::new(RwLock::new(0));%0A++++let+c_lock+=+Arc::clone(%26lock);%0A++++%0A++++let+_+=+thread::spawn(move+%7C%7C+%7B%0A++++++++let+_lock+=+c_lock.write().unwrap();%0A++++++++panic!();+//+the+lock+gets+poisoned%0A++++%7D).join();%0A++++%0A++++assert_eq!(lock.is_poisoned(),+true);%0A++++let+guard+=+lock.write().unwrap_or_else(%7Cmut+e%7C+%7B%0A++++++++**e.get_mut()+=+1;%0A++++++++lock.clear_poison();%0A++++++++e.into_inner()%0A++++%7D);%0A++++assert_eq!(lock.is_poisoned(),+false);%0A++++assert_eq!(*guard,+1);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_inner" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#600-606">Source</a></span><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.into_inner" class="fn">into_inner</a>(self) -&gt; <a class="type" href="../type.LockResult.html" title="type std::sync::LockResult">LockResult</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Consumes this <code>RwLock</code>, returning the underlying data.</p>
<h5 id="errors-7"><a class="doc-anchor" href="struct.RwLock.html#errors-7">Â§</a>Errors</h5>
<p>This function will return an error containing the underlying data if
the <code>RwLock</code> is poisoned. An <code>RwLock</code> is poisoned whenever a writer
panics while holding an exclusive lock. An error will only be returned
if the lock would have otherwise been acquired.</p>
<h5 id="examples-11"><a class="doc-anchor" href="struct.RwLock.html#examples-11">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::RwLock;

<span class="kw">let </span>lock = RwLock::new(String::new());
{
    <span class="kw">let </span><span class="kw-2">mut </span>s = lock.write().unwrap();
    <span class="kw-2">*</span>s = <span class="string">"modified"</span>.to_owned();
}
<span class="macro">assert_eq!</span>(lock.into_inner().unwrap(), <span class="string">"modified"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(String::new());%0A++++%7B%0A++++++++let+mut+s+=+lock.write().unwrap();%0A++++++++*s+=+%22modified%22.to_owned();%0A++++%7D%0A++++assert_eq!(lock.into_inner().unwrap(),+%22modified%22);%0A%7D&amp;edition=2024"></a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#633-636">Source</a></span><h4 class="code-header">pub fn <a href="struct.RwLock.html#method.get_mut" class="fn">get_mut</a>(&amp;mut self) -&gt; <a class="type" href="../type.LockResult.html" title="type std::sync::LockResult">LockResult</a>&lt;<a class="primitive" href="../../primitive.reference.html">&amp;mut T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable reference to the underlying data.</p>
<p>Since this call borrows the <code>RwLock</code> mutably, no actual locking needs to
take place â€“ the mutable borrow statically guarantees no new locks can be acquired
while this reference exists. Note that this method does not clear any previously abandoned locks
(e.g., via <a href="../../mem/fn.forget.html" title="fn std::mem::forget"><code>forget()</code></a> on a <a href="../struct.RwLockReadGuard.html" title="struct std::sync::RwLockReadGuard"><code>RwLockReadGuard</code></a> or <a href="../struct.RwLockWriteGuard.html" title="struct std::sync::RwLockWriteGuard"><code>RwLockWriteGuard</code></a>).</p>
<h5 id="errors-8"><a class="doc-anchor" href="struct.RwLock.html#errors-8">Â§</a>Errors</h5>
<p>This function will return an error containing a mutable reference to
the underlying data if the <code>RwLock</code> is poisoned. An <code>RwLock</code> is
poisoned whenever a writer panics while holding an exclusive lock.
An error will only be returned if the lock would have otherwise been
acquired.</p>
<h5 id="examples-12"><a class="doc-anchor" href="struct.RwLock.html#examples-12">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::RwLock;

<span class="kw">let </span><span class="kw-2">mut </span>lock = RwLock::new(<span class="number">0</span>);
<span class="kw-2">*</span>lock.get_mut().unwrap() = <span class="number">10</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>lock.read().unwrap(), <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::sync::RwLock;%0A++++%0A++++let+mut+lock+=+RwLock::new(0);%0A++++*lock.get_mut().unwrap()+=+10;%0A++++assert_eq!(*lock.read().unwrap(),+10);%0A%7D&amp;edition=2024"></a></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="struct.RwLock.html#trait-implementations" class="anchor">Â§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-RwLock%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#640-657">Source</a></span><a href="struct.RwLock.html#impl-Debug-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a> + <a class="trait" href="../../fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a>&gt; <a class="trait" href="../../fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#641-656">Source</a><a href="struct.RwLock.html#method.fmt" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="../../fmt/type.Result.html" title="type std::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="../../fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-RwLock%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#660-665">Source</a></span><a href="struct.RwLock.html#impl-Default-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../../default/trait.Default.html" title="trait std::default::Default">Default</a>&gt; <a class="trait" href="../../default/trait.Default.html" title="trait std::default::Default">Default</a> for <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#662-664">Source</a><a href="struct.RwLock.html#method.default" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>RwLock&lt;T&gt;</code>, with the <code>Default</code> value for T.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CT%3E-for-RwLock%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#668-674">Source</a></span><a href="struct.RwLock.html#impl-From%3CT%3E-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#671-673">Source</a><a href="struct.RwLock.html#method.from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked.
This is equivalent to <a href="../struct.RwLock.html#method.new" title="associated function std::sync::RwLock::new"><code>RwLock::new</code></a>.</p>
</div></details></div></details><section id="impl-RefUnwindSafe-for-RwLock%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/panic.rs.html#273">Source</a></span><a href="struct.RwLock.html#impl-RefUnwindSafe-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../../panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h3></section><section id="impl-Send-for-RwLock%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#87">Source</a></span><a href="struct.RwLock.html#impl-Send-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a> + <a class="trait" href="../../marker/trait.Send.html" title="trait std::marker::Send">Send</a>&gt; <a class="trait" href="../../marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h3></section><section id="impl-Sync-for-RwLock%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/sync/poison/rwlock.rs.html#89">Source</a></span><a href="struct.RwLock.html#impl-Sync-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a> + <a class="trait" href="../../marker/trait.Send.html" title="trait std::marker::Send">Send</a> + <a class="trait" href="../../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a>&gt; <a class="trait" href="../../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h3></section><section id="impl-UnwindSafe-for-RwLock%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> Â· <a class="src" href="https://doc.rust-lang.org/src/std/panic.rs.html#266">Source</a></span><a href="struct.RwLock.html#impl-UnwindSafe-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../../panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="struct.RwLock.html#synthetic-implementations" class="anchor">Â§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-RwLock%3CT%3E" class="impl"><a href="struct.RwLock.html#impl-Freeze-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; !<a class="trait" href="../../marker/trait.Freeze.html" title="trait std::marker::Freeze">Freeze</a> for <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;</h3></section><section id="impl-Unpin-for-RwLock%3CT%3E" class="impl"><a href="struct.RwLock.html#impl-Unpin-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="struct" href="../struct.RwLock.html" title="struct std::sync::RwLock">RwLock</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../../marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> + ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="struct.RwLock.html#blanket-implementations" class="anchor">Â§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#138">Source</a><a href="struct.RwLock.html#impl-Any-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../any/trait.Any.html" title="trait std::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#139">Source</a><a href="struct.RwLock.html#method.type_id" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="../../any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="../../any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#209">Source</a><a href="struct.RwLock.html#impl-Borrow%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211">Source</a><a href="struct.RwLock.html#method.borrow" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="../../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217">Source</a><a href="struct.RwLock.html#impl-BorrowMut%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218">Source</a><a href="struct.RwLock.html#method.borrow_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../../primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="../../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3C!%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#783">Source</a><a href="struct.RwLock.html#impl-From%3C!%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="../../primitive.never.html">!</a>&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#784">Source</a><a href="struct.RwLock.html#method.from-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="primitive" href="../../primitive.never.html">!</a>) -&gt; T</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#767">Source</a><a href="struct.RwLock.html#impl-From%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#770">Source</a><a href="struct.RwLock.html#method.from-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#750-752">Source</a><a href="struct.RwLock.html#impl-Into%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#760">Source</a><a href="struct.RwLock.html#method.into" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#806-808">Source</a><a href="struct.RwLock.html#impl-TryFrom%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#810">Source</a><a href="struct.RwLock.html#associatedtype.Error-1" class="anchor">Â§</a><h4 class="code-header">type <a href="../../convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../../convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#813">Source</a><a href="struct.RwLock.html#method.try_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#791-793">Source</a><a href="struct.RwLock.html#impl-TryInto%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#795">Source</a><a href="struct.RwLock.html#associatedtype.Error" class="anchor">Â§</a><h4 class="code-header">type <a href="../../convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#798">Source</a><a href="struct.RwLock.html#method.try_into" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>